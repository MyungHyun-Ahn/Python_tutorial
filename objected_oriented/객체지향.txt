객체 : 속성과 행동으로 이루어짐
> 우리가 살아가면서 보는 모든 존재
> 현실에 존재하든, 가상으로 존재하든 속성과 행동을 떠올릴 수 있다면 모두 객체이다.

객체 지향 프로그래밍 : 프로그램을 여러 개의 독립된 객체들과 그 객체들 간의 상호작용으로 파악하는 프로그래밍 접근법이다.
> 프로그램을 객체들과 객체들의 소통으로 바라보는 것

객체지향적으로 설계 > 모델링(modeling)

객체지향 프로그래밍으로 프로그램을 만들려면
프로그램에 어떤 객체들이 필요할지 정한다.
객체들의 속성과 행동을 정한다.
객체들이 어떻게 소통할지 정한다.

클래스와 인스턴스
객체의 틀 : 클래스
틀로 만든 결과물 : 객체
클래스로 객체를 만든다 = 클래스로 인스턴스를 만든다
객체 = 인스턴스 : 완전히 같지는 않지만 비슷한 의미

속성 > 변수로 행동 > 함수(메소드)로 나타냄.

메소드의 종류
인스턴스 메소스 : 인스턴스 변수를 사용하거나 인스턴스 변수에 값을 설정하는 메소드
> 규칙 1 : 인스턴스의 메소드를 호출하면 파라미터로 인스턴스가 자동으로 전달
> 규칙 2 : 첫번째 파라미터로 들어오는 인스턴스를 self로 쓰기를 권장

클래스 변수 : 같은 클래스 안의 인스턴스끼리 공유하는 변수
같은 이름의 클래스 변수 VS 같은 이름의 인스턴스 변수 : 같은 이름의 인스턴스 변수가 읽어짐

데코레이터(decorator) > 함수를 꾸며줌 @ 기호로 불러옴

클래스 메소드

인스턴스 변수 사용 > 인스턴스 메소드
클래스 메소드 사용 > 클래스 메소드

둘 다 쓴다면 > 인스턴스 메소드

인스턴스 없이도 필요한 정보가 있다면
클래스 메소드 User.count > 인스턴스가 없더라도 필요

인스턴스 변수나 클래스 변수 중 아무것도 사용하지 않을 때 > 정적 메소드 사용

파이썬으로 객체 지향 프로그래밍을 배우는 이유

파이썬이 순수 객체 지향 언어 > 파이썬의 모든 것이 객체
지금까지 써왔던 모든 것들이 어떤 객체의 인스턴스임

가변 타입 객체 : 한번 생성한 인스턴스의 속성 변경 가능 ex) list
불변 타입 객체 : 한번 생성한 인스턴스의 속성 변경 불가 ex) tuple

어떤 타입이냐에 따라 같은 상황에서도 다른 결과!

직접 작성하는 클래스는 가변 타입 > 인스턴스 변경 시 원래 인스턴스 속성을 바꾸면 됨!

ternary expression : 불린 값에 따라 다른 값을 리턴하는 구문
list comprehension : 새로운 리스트를 만드는 간편한 방법

객체 지향 프로그래밍의 4가지 기둥
1. 추상화(Abstraction)
2. 캡슐화(Encapsulation)
3. 상속(Inheritance)
4. 다형성(Polymorphism)

추상화
프로그래밍에서 추상화란?
프로그래머들이 특정 코드를 사용할 때 필수적인 정보를 제외한 세부사항을 가리는 것
함수의 세부 내용을 몰라도 사용법만 알면 사용할 수 있음

추상화를 잘 쓰는법
1. 변수, 함수, 클래스의 이름을 잘 짓기
2. 문서화하기 (docstring) > documentation string 문서화 문자열
    주석으로 달기 """주석""" 
    help() 메소드를 사용하면 문서를 볼 수 있음

파이썬의 type hinting
파이썬은 type이 동적임 > 정적 타입 언어처럼 타입 힌트를 적어주는 기능
: type / 변수의 타입 힌팅 콜론을 쓰고 타입명을 적어준다.
-> type / 리턴값의 타입 힌팅 화살표를 쓰고 타입명을 적어준다.

캡슐화
1. 객체의 일부 구현 내용에 대한 외부로부터의 직접적인 액세스를 차단하는 것
2. 객체의 속성과 그것을 사용하는 행동을 하나로 묶는 것

__를 붙이고 선언하면 클래스 외부에서 접근이 불가능함.
완벽하게 막은 것은 아님 name mangling > 새이름에 접근하면 사용가능
내부 메소드를 선언하면 사용가능

변수의 값을 읽는 메소드 > getter 메소드
변수의 값을 설정하는 메소드 > setter 메소드

중요한 변수는 값을 읽거나 설정하는 메소드를 만들면 안됨 ex) 주민번호

언더바 _ 1개 > 변수/메소드는 클래스 외부에서 직접 접근하지 마세요! 경고
getter setter 메소드를 추가하거나 다른 방식으로 변수를 사용하는 메소드 추가

파이썬이 언어 자체에서 캡슐화를 지원하지 않는 이유
파이썬의 문화 때문 > 캡슐화를 해도 OK 안해도 OK

property 데코레이터 : 캡슐화 전 사용하던 코드를 캡슐화 후 수정 X

객체를 사용할 땐 최대한 메소드를 이용
변수 직접 사용 최소화 > 유지 보수 쉬운 코드


상속
중복되는 코드를 사용하면 비효율적임

상속이란?
두 클래스 사이에 부모-자식 관계를 설정하는 것 

두클래스 사이에 A는 B다 라는 관계를 이루면 상속을 설정할 수 있음
A 클래스의 개념이 B 클래스의 개념에 포함되면 되는 것
B : 부모 클래스 / A : 자식 클래스 > 자식 클래스는 부모 클래스의 모든 변수와 메소드를 물려받음.

클래스들의 공통 부분을 추출하여 부모 클래스를 만듬.

오버라이딩 : 자식 클래스가 부모 클래스로부터 물려받은 내용을 자신에 맞게 변경하는 것
덮어씌운다는 의미

오버라이딩 > 자식 클래스에서 물려받은 메소드 > 같은 이름의 메소드를 내용을 바꿔 정의

super 함수 > 부모 클래스의 메소드를 호출 가능

mro : 클래스가 상속받는 부모 클래스들이 순서대로 담긴 리스트를 리턴

메소드 검색 방향 : 자식 -> 부모 / 자식에서 먼저 찾고 없으면 부모

다중 상속 : 부모가 둘
Python : 다중 상속 가능
Java : 다중 상속 불가능
다중 상속 문제점 해결
1. 부모클래스끼리 같은 이름의 메소드를 갖지 않도록 하기
2. 같은 이름의 메소드는 자식클래스에서 오버라이딩


다형성
여러가지 형태를 갖는 성질
하나의 변수가 서로 다른 클래스의 인스턴스를 가리킬 수 있는 성질을 다형성이라함

공통 부모 클래스

추상 클래스 : 여러 클래스들의 공통점을 추상화해서 모아놓은 클래스
             여러 클래스들의 공통점을 담아두고 다른 클래스들이 상속받는 부모 클래스가 될 목적으로 존재


추상 클래스에도 일반 메소드 추가 가능

1. 옵셔널 파라미터 : 옵션으로 주는 파라미터 기본값 설정가능
2. 파라미터 이름 명시
3. 개수가 확정되지 않은 파라미터

보통은 클래스 다형성이지만 함수/메소드 다형성도 있다.

LBYL Look Before You Leap (뛰기 전에 살펴보라)
돌다리도 두드려보고 건너라!
> 어떤 작업을 수행하기 전에 그 작업을 수행해도 괜찮을지 확인

<> 서로 반대

EAFP Easier to Ask for Forgiveness than Permission
허락보다 용서가 쉽다!
> 일단 먼저 빨리 실행하고, 문제가 생기면 처리한다
try: catch: 문 사용

견고한 객체 지향 프로그래밍

SOLID 원칙 '견고한'
SOLID의 모든 원칙을 지키면 유지 보수하기 쉬운 '견고'한 코드를 작성가능

1. 단일 책임 원칙 (Single Responsibility)
2. 개방 폐쇄 원칙 (Open-Closed Principle)
3. 리스코프 치환 원칙 (Liskov Substitution)
4. 인터페이스 분리 원칙 (Interface Segregation Principle)
5. 의존 관계 역전 원칙 (Dependency Inversion Principle)


1. 단일 책임 원칙 (Single Responsibility)
모든 클래스는 단 한가지의 책임만을 갖고, 
클래스 안에 정의되어 있는 모든 기능은,
이 하나의 책임을 수행하는데 집중되어 있어야 한다.
> 하나의 클래스로 너무 많은 일을 하지 말고 딱 한가지 책임만 수행하라는 뜻

한 가지 책임?  > 사람마다 다름 / 그때그때 결정
하나의 클래스에서 많은 책임을 지는 것 > God Object
> 기능을 분리하여 구현

어떤 프로그램이냐, 어떤 개발자냐에 따라 생각이 다름.
> 단일 책임 원칙에 명확한 정답은 없다.

코드를 작성할 때, 단일 책임 원칙 신경 쓰기!
> 책임이 너무 많음 > 클래스에 분리할 수 있는 변수와 메소드가 많으면 의심!

단일 책임 원칙을 지키게 되면 프로그램의 유지 보수가 쉬워짐.


2. 개방 폐쇄 원칙 (Open-Closed Principle)
클래스는 확장에 열려 있어야하며, 확장에 닫혀 있어야한다.

확장에 열려 있다. : 프로그램의 기존 기능을 확장할 수 있다는 것
수정에 닫혀 있다. : 한 번 작성한 코드를 바꾸지 않아도 된다는 것

다형성을 사용하면 개방 폐쇄 원칙을 적용할 수 있다.
> 추상 클래스를 사용

개방 폐쇄 원칙 > isinstance 사용
> 개발의 편의성 UP, 코드의 유지보수성 UP

isinstance를 사용한다면 모든 클래스를 일일히 확인해야함..

개방폐쇄원칙을 지키는 이유
> 더 쉽게 협력하고 더 편하게 수정하기 위해서


3. 리스코프 치환 원칙 (Liskov Substitution)
부모 클래스의 인스턴스를 사용하는 위치에
자식 클래스의 인스턴스를 대신 사용했을 때
코드가 원래 의도대로 작동해야 한다.

자식 클래스의 인스턴스는 부모 클래스의 인스턴스 이기도 하다.
isinstance(자식 클래스의 인스턴스, 부모 클래스)  => True

부모 클래스의 행동규약을 자식 클래스가 어기지 말것.

자식 클래스가 오버라이딩을 잘못 하는 경우
1. 자식 클래스가 부모 클래스 변수의 타입을 바꾸거나
   메소드의 파라미터 또는 리턴값의 타입 or 갯수를 바꾸는 경우
2. 자식 클래스가 부모 클래스의 의도와 다르게 메소드를 오버라이딩 하는 경우

A는 B다. < 상속
A가 B의 행동규약을 지키는가?를 파악하고 상속을 결정해야 문제가 없음.

리스코프 치환 원칙은 개발자들이 협력할 때 특히 중요.
> 리스코프 치환 원칙을 지키는 것은 나뿐만 아니라 다른 개발자를 위해서도 중요합니다!

