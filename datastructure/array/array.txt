배열 (파이썬 리스트와 비슷)

C(배열)  ->  파이썬(리스트)

C 배열
- 크기가 고정돼 있다.
- 같은 타입의 데이터만 담을 수 있다.

int numArray[4];
int 4바이트 * 4칸 = 16바이트의 메모리 할당
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;
|  2  |  3  |  5  |  7  |
데이터가 메모리에 연속적으로 저장

파이썬 리스트
|  레퍼런스 -> 2  |  레퍼런스 -> 3  |  레퍼런스  -> 5 |  레퍼런스  -> 7  |
>> 각각 데이터를 가리키고 있음
데이터가 메모리의 랜덤으로 저장

배열은 가장 기본적인 자료구조이기 때문에 중요!


배열에 데이터를 저장하고 가지고 오는 법
int numArray[4];
numArray[0] = 2;
numArray[1] = 3;
numArray[2] = 5;
numArray[3] = 7;

|  2  |  3  |  5  |  7  |
1000  1004  1008  1012
배열의 요소들이 메모리에 순서대로, 그리고 연속적으로 저장
인덱스 i 주소 1000 + 4 * i
    시작주소 + 데이터 크기 * 인덱스
배열 인덱스 접근 시간 복잡도 : O(1)


배열 탐색
배열에서 탐색은 접근보다 비효율적 > 하나하나 모든 값을 다 봐야하기 때문

배열에 값이 n개가 있다면 최악의 경우 n개의 값을 모두 봐야하므로
시간 복잡도 : O(n)


배열 (Static Array)

정적 배열 : 크기 고정 (요소 수 제한)
동적 배열 : 크기 변함 (요소 계속 추가 가능)

정적 배열 

정적 배열에서 삽입
|  2  |  3  |  5  |  7  |  11  |
intArray

배열을 복사한뒤 +1 칸만큼 할당 받고 삽입
|  2  |  3  |  5  |  7  |  11  |  13  |
intArray

메모리 공간은 띄엄띄엄 있으면 안되고 쭉 연결된 공간이어야 함.
사용할 수 있는 공간을 찾아 값을 저장한다고 가정했을 때
이 공간이 써도 되는 공간인지 알 수 없음.
위험성을 미리 예방하기 위해 배열은 저장할 수 있는 공간을 고정해놓음.

그렇다고 배열을 쓸데없이 크게 정의하면, 메모리를 많이 낭비하게됨.

동적 배열 (Dynamic Array)

- 정적 배열로 만들어진 자료구조
- 정적 배열의 크기를 상황에 맞게 조절

동적 배열에서 삽입

|  2  |  3  |  5  |  7  |  11  |
intDynamicArray  // 5개를 담을 수 있는 배열이 있다면

|  2  |  3  |  5  |  7  |  11  |  13  |     |     |     |     |
intDynamicArray  
// 2배의 용량을 할당하여 10칸을 할당하고 새로운 값을 다음 칸에 저장함
>> 계속 2배씩 공간을 늘려가며 할당함

파이썬 리스트 = 동적 배열 / 값을 삽입하지 않은 뒷부분은 접근하지 못함.

추가 연산 (append operation)

- 경우 1: 정적 배열 남는 공간 있을 때
        그냥 비어있는 공간의 가장 앞부분에 삽입 O(1)

- 경우 2: 정적 배열이 꽉 찼을 때
        현재 사용 중인 배열보다 두 배로 메모리 공간을 예약하고
        기존 배열에서 새로운 배열로 값을 싹 다 복사한 뒤
        마지막으로 새 값을 빈칸에 추가 O(n)

정리 : 최고의 경우 O(1)  < 자주 일어남
       최악의 경우 O(n)  < 가끔 일어남

분할 상환 분석 (Amortized Analysis) : 쉽게 말해 할부
- 같은 동작을 n 번 했을 때 드는 시간이 X일 때
    : 동작을 한 번 하는데 걸린 시간 : X / n


삽입 연산 (insert operation)
추가 : append 는 맨 끝에 추가 하는 것'
삽입 : 원하는 곳에 값을 추가 insertion

- 경우 1 : 정적 배열에 남는 공간이 있을 때
           삽입할 위치 뒤의 요소들을 한칸씩 밀어준 뒤 값을 삽입함.
           시간 복잡도 : O(n)

- 경우 2 : 정적 배열이 가득 찼을 때
           새로운 배열을 만든 후 삽입할 위치 뒤의 요소들을 한칸씩 밀어준 뒤
           값을 삽입함. 시간 복잡도 : O(n) + O(n) = O(n)

정리 : 삽입 연산 시간 복잡도 : O(n)

삭제 연산 (delete operation)

- 최악의 경우 : 삭제할 값을 삭제한 후 배열의 요소를 한칸씩 앞으로 밀어줌. O(n)

- 최고의 경우 : 맨 뒤의 값을 삭제함. O(1)

동적 배열의 크기 줄이기
크기를 줄일 때는 내부 배열의 사용 비율이 특정 값 이하로 떨어질 때
자동으로 동적 배열의 크기를 줄여줌.


배열 vs 동적 배열
시간 복잡도 : n은 요소 갯수
                배열    |  동적 배열
접근(access)    O(1)    |     O(1)
탐색(search)    O(n)    |     O(n)
삽입(insert)     N/A    | O(n), 맨뒤 O(1)
삭제(delete)     N/A    | O(n), 맨뒤 O(1)

배열은 삽입과 삭제를 자유롭게 하지 못함.
동적 배열은 가능

낭비하는 공간
- 배열 : 크기가 고정되어 있기 때문에 낭비하는 공간이 없다!
- 동적 배열 : 공간을 낭비할 수도 있고 안 할 수도 있다!
        최악의 경우 : 새로운 배열을 만들었을 때, 낭비되는 공간이 가장 크다. 최소 0 ~ 최고 n-2까지 낭비
                     즉 : O(n) 만큼 낭비



