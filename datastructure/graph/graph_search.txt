그래프 탐색
하나의 시작점 노드에서 연결된 노드들을 모두 찾는 것

그래프 탐색 종류
- Breadth First Search
- Depth First Search

Breadth First Search(BFS) 
  너비   우선   탐색
 - 인접 노드들을 탐색하며 진행 즉, 가까운 노드 먼저 진행
 - 그래프를 너비 우선적으로 탐색!
 - 너비 우선 탐색 구현 방법
   * 시작점 노드를 방문한 노드 표시 후, 큐에 넣는다.
   * 큐에 아무 노드도 없을 때까지:
    1. 큐에서 가장 앞 노드를 꺼낸다.
    2. 이 노드에 인접해 있는 노드들을 돌면서:
      1. 처음 방문한 노드라면:
        1. 방문한 노드로 표시한다.
        2. 큐에 넣는다.

 - BFS 시간 복잡도
   * BFS 노드 전처리 : O(V)
   * 큐에 노드를 넣고 빼는 데 걸리는 시간 O(V)
   * 큐에서 뺀 노드의 인접한 노드들을 도는데 걸리는 시간 O(E)
   * 총 시간 복잡도 : O(V+E)

Depth First Search(DFS)
 깊이  우선   탐색
 - 인접 노드를 탐색하며 진행하는데 최대한 멀리가는 최대한 깊이 탐색하는 방법이다.
 - 그래프를 깊이 우선적으로 탐색!
 - 깊이 우선 탐색 구현 방법
   * 시작점 노드를 옅은 회색 표시 후, 스택에 넣는다.
   * 스택에 아무 노드도 없을 때까지:
     1. 스택에서 가장 위 노드를 꺼낸다.
     2. 짙은 회색(방문 처리) 표시를 한다.
     3. 이 노드에 인접해 있는 노드들을 돌면서:
       1. 노란색 노드면:
         1. 옅은 회색으로 표시한다.
         2. 스택에 넣는다.
 - DFS 시간 복잡도
   * DFS 노드 전처리 : O(V)
   * 스택에 노드를 넣고 빼는 데 걸리는 시간 O(V)
   * 스택에서 뺀 노드의 인접한 노드들을 도는데 걸리는 시간 O(E)
   * 총 시간 복잡도 : O(V+E)


최단 경로 알고리즘
두 노드 사이 경로 중 가장 거리가 짧은 경로를 구하는 방법
 - BFS
 - Dijkstra

BFS 최단 경로 알고리즘
 - visited 변수에 추가로 predecessor(이전의 것) 변수를 추가
 - predecessor : BFS를 할 때 특정 노드에 오기 직전의 노드를 저장
 - 최단 경로용 BFS 구현
   * 시작점 노드를 방문한 노드 표시 후, 큐에 넣는다.
   * 큐에 아무 노드도 없을 때까지:
    1. 큐에서 가장 앞 노드를 꺼낸다.
    2. 이 노드에 인접해 있는 노드들을 돌면서:
      1. 처음 방문한 노드라면:
        1. 방문한 노드로 표시한다.
        2. predecessor 변수를 큐에서 꺼낸 노드로 설정
        3. 큐에 넣는다.
 - Backtracking
   1. 현재 노드를 경로에 추가한다.
   2. 현재 노드의 predecessor로 간다.
   3. predecessor가 없을 때까지 위 단계들 반복

Dijkstra 알고리즘
가중치가 있는 그래프에서 최단 경로를 구하는 알고리즘이다.
 - 세가지 변수가 필요하다.
   * distance : 최단 거리 예상치(현재까지 아는 정보로 계산한 최단 거리)
     > 더 짧은 경로를 찾으면 갱신
   * predecessor : 현재까지 최단 경로에서 바로 직전의 노드
   * complete : 노드까지의 최단 경로를 찾았다고 표시하기 위한 변수
 - 엣지 Relaxation
   * 노드A에서 노드B를 방문하면서, 노드B의 distance, predecessor를 바꾸는 것
     > 엣지 (A, B)를 relax 한다. 라고 함.
 - Dijkstra 알고리즘 구현
   * 시작점의 distance를 0으로, predecessor를 None으로
   * 모든 노드가 complete 일 때까지:
     1. complete하지 않은 노드 중 distance가 가장 작은 노드 선택
     2. 이 노드에 인접한 노드 중 complete하지 않은 노드를 돌면서:
       1. 각 엣지를 relax한다.
     3. 현재 노드를 complete 처리한다.
 - Dijkstra 알고리즘으로 찾은 경로가 최단 경로인 이유
   1. Dijkstra 알고리즘은 반복문을 돌면서 최단 경로를 이미 찾은 노드를 하나씩 찾아준다.
     1. 처음에는 시작 노드의 최단 경로를 확정 지었고, 그 다음에는 C이 최단 경로를 확정지었다.
   2. 그리고 최단 경로를 이미 찾은 노드들의 엣지들은 모두 relax 해주었다.
     1. 최단 경로는 다른 노드들까지의 경로 + 현재 노드기 때문에, 이미 확정난 최단 경로들로 다른 노드들까지의 distance를 구하는 것
   3. 매 단계에서 이 distance가 가장 작은 노드는 최단 거리를 이미 찾았다고 확신을 할 수 있다.
     1. 노드 D까지 가는 최단 거리는 이 세 가지 가능성 중 하나일 수밖에 없습니다. (최적 부분 구조)
       1. C까지 가는 최단 경로 거리 + 엣지 (C, D)의 가중치
       2. B까지 가는 최단 경로 거리 + 엣지 (B, D)의 가중치
       3. E까지 가는 최단 경로 거리 + 엣지 (E, D)의 가중치
     2. D가 선택됐다는 건 현재 찾은 경로( A - C - D)의 거리가 B까지 가는 최단 거리, 
        E까지 가는 최단 거리보다 작기 때문입니다. 
        그렇기 때문에 반복문이 한 번 실행될 때마다 distance가 가장 작은 노드가 최단 거리 노드라고 확신할 수 있죠.