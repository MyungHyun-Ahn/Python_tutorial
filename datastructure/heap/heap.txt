힙
 - 형태 속성 : 힙은 완전 이진 트리다. - 높이가 O(lg(n))
 - 힙 속성 : 모든 노드의 데이터는 자식 노드들의 데이터보다 크거나 같다.

힙 정렬
 - 정렬 알고리즘 : 데이터를 재배치하는 구체적인 방법


힙 구현하기
 - 완전 이진 트리이므로 동적 배열로 구현!

배열로 구현한 완전 이진 트리에서 자식 인덱스를 구하는 법
 - 왼쪽 자식 인덱스 : 인덱스 * 2
 - 오른쪽 자식 인덱스 : 인덱스 * 2 + 1

heapify 알고리즘
 - heapify는 파라미터로 노드하나를 받음.
 - 이 노드를 부모 노드라 하고
 - 부모 노드, 왼쪽 자식, 오른쪽 자식 중 가장 큰 것을 고름
 - 가장 큰 노드와 부모 노드를 바꾸어줌.
 - 이것을 힙 속성을 충족할 때까지 반복함
힙은 완전 이진 트리이므로 높이가 O(lg(n))
따라서 최악의 경우 heapify에 걸리는 시간은 O(lg(n))에 비례
즉, 시간 복잡도도 O(lg(n))

heapify 함수에 어떤 노드를 넣어주면?
 - 파라미터로 넘기는 노드가 힙에서 위치를 찾아간다.
 - 완전 이진 트리가 파이썬 리스트로 구현되어 있을 때
 - 마지막 인덱스부터 첫 인덱스까지 차례로 heapify를 호출하면 힙으로 만들 수 있음.
 - 시간복잡도는 n개의 노드가 있고 heapify 함수는 log(n)임
 - 힙을 만들려면 heapify를 n개의 노드에 모두 호출해야 함.
 - 즉, 시간복잡도는 O(nlog(n))


 힙 정렬
  - 힙을 이용한 정렬 알고리즘!
  
 힙 정렬 순서 
  - 힙을 만든다
  - root와 마지막 노드를 바꿔준다
  - (바꾼 노드는 없는 노드 취급한다)
  - 새로운 노드가 힙속성을 지킬 수 있게 heapify 호출
Q 내림차순으로 정리하고 싶다면?
 - 힙 속성을 반대로 바꾸고 똑같은 알고리즘을 적용하면 된다.

정렬 알고리즘  |	       시간 복잡도          |
  선택 정렬    |	         O(n^2)            | 
  삽입 정렬    |	         O(n^2)            |
  합병 정렬    |	        O(nlg(n))          |
   퀵 정렬	   |  평균 O(nlg(n)) (최악 O(n^2))  |
   힙 정렬     |	        O(nlg(n))          |

힙의 삽입 연산 시간 복잡도 - O(lg(n))
힙의 추출 연산 시간 복잡도 - O(lg(n))
