추상 자료형

기능 vs 구현 : 차이 구분, 서로 다른 개념임
 - 기능 : 연산이 "무엇"을 하는지에 대한 설명 
 - 구현 : 기능을 "어떻게" 하는지에 대한 설명

추상화
 - 구현을 몰라도 기능만 알면 사용할 수 있게 해주는 것을 '추상화 했다'라고 표현

추상 자료형(Abstract Data Type)
 - 자료구조를 추상화 한 것
 - 데이터를 저장/사용할 때 기능만 생각
> 데이터에 무엇을 하고 싶은지 그러니까 연산의 기능들만 가지고 있는 것.

추상 자료형 예시
* 리스트
데이터간 순서 관계를 유지할 수 있다.
 - 접근 연산 : 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
 - 탐색 연산 : 특정 조건을 만족하는 데이터를 찾는다.
 - 삽입 연산 : 특정 위치에 새로운 데이터를 저장한다.
 - 삭제 연산 : 특정 위치에 있는 데이터를 지운다.

자료구조(Data Structure)
> 정확히 데이터를 어떻게 저장할 건지 데이터 간 관계를 어떻게 유지할 건지 
  각 연산들을 구체적으로 어떻게 할지 등을 묶어 놓은 것.

자료구조 예시
* 동적 배열
데이터를 메모리에 순서대로 그리고 연속적으로 저장한다.
 - 접근 연산 : 인덱스 주소를 한 번에 계산해서 메모리에 접근한다.
 - 탐색 연산 : 가장 앞 인덱스부터 선형적으로 모든 데이터를 확인한다.
 - 삽입 연산 : 인덱스 뒤 데이터를 한 칸씩 뒤로 밀고, 데이터를 저장한다.
 - 삭제 연산 : 데이터를 지우고 뒤 인덱스들을 하나씩 앞으로 옮겨서 저장한다.

 추상 자료형인 리스트를 자료구조인 동적 배열이나 링크드 리스트로 구현할 수도 있다.
> 구현의 방법은 다양함.

프로그래밍을 할때 자료구조를 떠올리는 것보다 추상 자료형을 떠올리는 것이 쉽다.
> 즉, 구현이 필요없는 기능에 대한 내용을 떠올린 뒤 > 자료구조를 떠올리자!
                             기능 > 구현
> 추상 자료형을 생각하면 코드의 흐름에 집중할 수 있다!

기능에 중점 / 흐름을 생각할 때 / 구현에 집중할 필요가 없을 때 > 추상 자료형을 중심적으로 생각
코드의 성능을 분석 / 최적화 / 성능을 최대로 끌어올리고 싶을 때 > 자료구조를 중심적으로 생각


리스트 (List)

리스트 : 추상 자료형
데이터간 순서 관계를 유지할 수 있다.
 - 접근 연산 : 특정 위치에 있는 데이터를 가지고 오거나 수정한다.
 - 탐색 연산 : 특정 조건을 만족하는 데이터를 찾는다.
 - 삽입 연산 : 특정 위치에 새로운 데이터를 저장한다.
 - 삭제 연산 : 특정 위치에 있는 데이터를 지운다.

파이썬
 - 추상화가 많이 된 고수준 언어
 - 많은 자료형 이름이 추상 자료형!
> 개발자들이 구현보다 기능에 집중할 수 있게 해줌

파이썬 자료형 list > 구현을 몰라도 기능만 알고 사용할 수 있음!

리스트 구현 > 동적배열, 링크드 리스트

              |  동적 배열    | 더블리 링크드 리스트 |
     접근     |      O(1)     |         O(n)       |
     탐색     |      O(n)     |         O(n)       |
  접근 + 탐색  |     O(n)     |         O(n)       |
  접근 + 삭제  |     O(n)     |         O(n)       |
              |              |                    |
   맨 앞 삽입  |     O(n)     |         O(1)       | 
   맨 앞 삭제  |     O(n)     |         O(1)       |
   맨 뒤 삽입  | 분할 상환 O(1) |        O(1)       |
   맨 뒤 삭제  | 분할 상환 O(1) |        O(1)       |

동적 배열 : 데이터를 수정 / 가져오는 접근연산
           맨 끝에 데이터를 추가하거나 삭제하는 연산이 효율적
           파이썬 리스트는 동적 배열로 구현되어 있음.

링크드 리스트 : 처음과 끝에 데이터를 추가하거나 삭제하는 연산이 효율적

자료구조를 고르는 법
> 어떤 기능을 많이 사용할지를 생각하고 자료구조를 선택!
> 시간 복잡도를 비교하여 자료구조를 선택


큐 (Queue)
데이터를 앞에서만 삭제하고 뒤에서만 삽입 : FIFO : First-In-First-Out
가장 먼저 들어온 데이터가 가장 먼저 나간다!

* 큐 (Queue)
데이터간 순서 관계를 유지할 수 있다.
 - 맨 뒤 데이터 추가
 - 맨 앞 데이터 삭제
 - 맨 앞 데이터 접근

파이썬 deque
 - Doubly-ended-Queue의 약자
 - 맨 앞과 뒤에 데이터를 삽입하고 삭제할 수 있게 해주는 자료형

큐 구현 > 동적 배열, 링크드 리스트

              동적 배열    | 더블리 링크드 리스트 |
맨 앞 삭제 |      O(n)     |         O(1)       |
맨 뒤 삽입 | 분할 상환 O(1) |         O(1)       |
맨 앞 접근 |      O(1)     |         O(1)       |

> 더블리 링크드 리스트로 구현하는 것이 더 효율적!


스택 (Stack)
데이터를 항상 맨 끝에 추가하고 맨 끝에 데이터를 삭제 : LIFO : Last-In-First-Out

* 스택 (Stack)
데이터간 순서 관계를 유지할 수 있다.
 - 맨 뒤 데이터 추가
 - 맨 뒤 데이터 삭제
 - 맨 뒤 데이터 접근

파이썬 deque 를 사용해서 스택으로 사용할 수 있음!

스택 구현 > 동적 배열, 링크드 리스트

              동적 배열    | 더블리 링크드 리스트 |
맨 뒤 삭제 | 분할 상환 O(1) |         O(1)       |
맨 뒤 삽입 | 분할 상환 O(1) |         O(1)       |
맨 앞 접근 |      O(1)     |         O(1)       |

> 파이썬 리스트(동적 배열)를 사용하거나 deque(더블리 링크드 리스트)를 사용해도 같음


* 딕셔너리 (Dictionary) - 가끔씩 맵이라고 부르기도 함. map
데이터간 순서 관계를 약속하지 않음
 - key - value 데이터 쌍 삽입
 - key를 이용한 데이터 탐색
 - key를 이용한 데이터 삭제

 딕셔너리 구현 > 해시 테이블

                  | 해시 테이블 |
 key-value 쌍 삽입 |    O(1)    |
 key를 이용한 탐색 |    O(1)    |
 key를 이용한 삭제 |    O(1)    |

> 평균적으로 모두 O(1)


* 세트(Set)
데이터간 순서 관계를 약속하지 않음
 - 삽입 : 데이터를 저장할 수 있다 (중복 데이터 X)
 - 탐색 : 데이터가 저장됐는지 확인할 수 있다.
 - 삭제 : 저장한 데이터를 지울 수 있다.
