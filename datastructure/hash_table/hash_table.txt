
key - value 데이터
저장한 정보를 검색할 수 있는 데이터 유형을 key - value 데이터 라고 부름.

ex)
101호: 최지웅
711호: 김현승
942호: 손동욱
204호: 강영훈
302호: 성태호
  key: value

 - 하나의 key와 그 key에 해당하는 value를 합쳐서: key - value 쌍이라고함.
 - 하나의 key에는 하나의 value만 있어야 된다!


배열 : Direct Access Table 
 - 인덱스를 key하고 생각하고 저장
 - 인덱스를 이용한 value 접근 O(1)

위의 예시를 배열로 표현했을때 
 - 사용하는 인덱스: 5
 - 낭비하는 인덱스: 938

> 접근은 O(1)이므로 효율적임!
> 그런데 낭비되는 공간이 너무 많다!

해시 테이블(Hash Table)
 - 해시 함수
    * 특정 값을 원하는 범위의 자연수로 바꿔주는 함수

 - 해시 테이블은 이 해시 함수와 배열을 같이 사용하는 자료 구조이다.
    * 키를 바로 인덱스로 사용하지 않고 해시 함수에 넣어서 리턴된 값을 인덱스로 사용

 - 정리
    * 해시 테이블은 고정된 크기의 배열을 만들고
    * 해시 함수를 이용해서 키를 원하는 범위의 자연수로 바꾸어 준 후
    * 해시 함수의 리턴값 인덱스에 key - value 쌍을 저장하는 자료구조이다!

해시 함수를 만드는 간단한 두 가지 방법

1. 나누기 방법
    - 자연수 key를 해시 테이블의 크기로 나눈 나머지를 리턴하는 방법
    - 어떤 키가 들어와도 0 ~ 원하는 정수 범위의 자연수로 바꾸어줌

2. 곱셈 방법
    - 먼저 0 < a < 1 인 아무 값 a를 정함.
    - a * key를 하고 정수 부분은 버리고 소수 부분만 남김
    - 마지막으로 남은 소수 부분에 배열의 크기를 곱해준 뒤 
    - 소수점 부분을 버리고 남은 값을 리턴함

해시 함수로 사용하려면 만족해야하는 조건
    - 결정론적이어야 된다.
    - 원하는 범위의 자연수 하나하나가 리턴될 확률이 최대한 비슷해야 한다.
    - 빨리 계산할 수 있어야 한다.

파이썬의 hash 함수
 - 파이썬의 해시 함수는 파라미터로 받은 값을 그냥 아무 정수로만 바꾸어줌.
 - 불변 타입 자료형에만 사용할 수 있음.

불변 타입 자료형
 * 불린형
 * 정수형
 * 소수형
 * 튜플
 * 문자열


해시 테이블의 충돌(Collision)

 - 해시 함수를 사용하여 받은 리턴값이 중복되는 경우
 - 이미 사용되고 있는 인덱스에 새로운 key - value 쌍을 또 저장해야함.
 - 이때 충돌(Collision)이 일어났다고 표현

체이닝(Chaining)
 - 충돌을 처리하는 방법중 하나
 - 말 그대로 충돌이 일어나면 그 값들을 쇠사슬 처럼 엮겠다는 뜻.

 - 배열 인덱스에 링크드 리스트 저장해서 충돌 해결


해시 테이블 연산

해시 테이블 탐색 연산
 - 원하는 key에 해당하는 value를 찾는 연산

 - 시간 복잡도
    해시 함수 계산 : O(1)
    배열 인덱스 접근 : O(1)
    링크드 리스트 탐색 : O(n)
    총 합 : O(n)


해시 테이블 삽입
 - key - value 데이터 쌍을 저장, 또는 수정
    * key를 해시 함수에 넣고 그 결과값을 이용하여
    * 배열의 인덱스에 접근하여 
    * 저장된 링크드 리스트에 원하는 키를 갖는 노드가 있는지 탐색
    * 링크드 리스트에서 삽입하려는 키가 이미 있는지 탐색
    * 중복되는 키가 이미 있다면 해당하는 키값의 벨류를 바꾸어줌 (하나의 키에는 하나의 벨류만 가질수 있기 때문)
    * 중복되는 키가 없다면 링크드 리스트의 맨 끝에 새로운 노드를 추가

 - 시간 복잡도
    해시 함수 계산 : O(1)
    배열 인덱스 접근 : O(1)
    링크드 리스트 노드 탐색 : O(n)
    랑크드 리스트 노드 저장 / 노드 수정 : O(1)
    총 합 : O(n)


해시 테이블 삭제
 - 특정 key에 대한 key - value 데이터 쌍을 삭제
    * 저장된 링크드 리스트에서 원하는 key에 대한 노드를 탐색 후 삭제

 - 시간 복잡도
    해시 함수 계산 : O(1)
    배열 인덱스 접근 : O(1)
    링크드 리스트 노드 탐색 : O(n)
    랑크드 리스트 노드 삭제 : O(1)
    총 합 : O(n)

링크드 리스트의 탐색이 n에 비례하는 이유 
 - 모든 데이터가 하나의 링크드 리스트에 저장된 경우 때문
 - 배열에 저장된 각 링크드 리스트 길이가 average_lenght라면?
 - O(average_lenght)가 걸린다고 할 수 있음.

배열에 저장되어 있는 링크드 리스트의 평균 길이
 - 총 들어 있는 key - value 쌍 수를 배열 인덱스 수로 나누어 주면 됨.
    * 해시 테이블에 총 들어가 있는 key - value 쌍의 수 : n
    * 해시 테이블이 사용하는 배열의 크기 : m
    * 링크드 리스트의 평균 길이 : n / m

> 따라서 탐색의 시간 복잡도는 O(n/m) 라고 표현할 수 있음!

Open Addressing
 - 해시 테이블의 충돌 해결법 중 하나
 - 충돌이 일어났을 때 비어있는 인덱스를 찾아감.

비어있는 인덱스를 찾는 방법
 - 선형 탐사(linear probing)
    * 충돌이 일어났을 때, 한 칸씩 다음 인덱스가 비었는지 확인 (선형적)

 - 제곱 탐사
    * 제곱만큼 뒤로 이동하며 빈 인덱스를 확인
    * n번째 칸이 차있었다면?
    * n + 1*1 = n + 1 칸 확인
    * n + 2*2 = n + 4 칸 확인
    * n + m*m = n + m*m 칸 확인
    * 제곱한 값을 이용해서 인덱스를 찾는 방법


Open Addressing 탐색
 - 선형 탐사를 이용해서 데이터를 찾음
    * 인덱스에 찾는 값이 없으면 다음 인덱스로 넘어가며 순차적으로 탐색함.
    * 빈 인덱스를 찾은 경우에는 그 데이터가 처음부터 저장되지 않았다는 뜻.
    * Open Addressing으로 데이터를 저장했을 경우 
    * 처음부터 순차적으로 저장하기 때문에 비어있는 데이터가 있을 수 없음.

Open Addressing 삭제
 - 데이터를 단순히 삭제하면 안됨 중간에 비어있는 인덱스가 생길수도 있기 때문.
 - 해결
    * 데이터를 삭제하고 이 자리에 원래 데이터가 있었지만 지금은 삭제되었음을 표시

Open Addressing 시간 복잡도

연산 | 시간 복잡도 (최악의 경우)
삽입 |     O(n)
탐색 |     O(n)
삭제 |     O(n)

load factor
 - 해시 테이블 연산들을 분석할 때 사용하는 것
    * 해시 테이블이 사용하는 배열의 크기 : m
    * 해시 테이블 안에 들 어있는 데이터 쌍 수 : n
    * load factor a = n / m
    * 그냥 해시 테이블이 얼마나 차있는지 나타내는 변수
    * 해시 테이블 안에 배열의 크기보다 많은 key - value 쌍을 저장할 수 없기 때문에
    * load factor a는 항상 1보다 작다

 - 결과
    * Open Addressing을 사용하는 해시 테이블에서 평균적으로 탐사를 해야 되는 횟수는 1 / (1 - a) 보다 작다.
    * 0 < a < 0.9 일 때 평균적으로 항상 10보다 적게 탐사할수 있음
    즉, 평균적으로 O(10), O(1)이라고 할 수 있음.







