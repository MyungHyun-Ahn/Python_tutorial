더블리 링크드 리스트

- 구조
    next가 다음 노드를 가리키고
    prev가 이전 노드를 가리키는 구조

      head node                             tail node
    |    data    |     |    data    |     |    data    |
    |    next    |  >  |    next    |  >  |    next    |
    |    prev    |  <  |    prev    |  <  |    prev    |

싱글리 링크드 리스트와 겹치는 연산들

다음 노드로 이동하며 접근 / 탐색을 하는 부분이 동일
 - __init__ 메소드
 - find_node_at 접근 연산
 - find_node_with_data 탐색 연산
 - __str__

 
더블리 링크드 리스트 추가 연산

 - 리스트가 비었을 때
    * head와 tail을 새로운 노드로 설정해줌.

 - 리스트가 비어있지 않을 때
    * tail의 next가 새로운 노드를 가리키게 하고
    * 새로운 노드의 prev가 tail을 가리키게 한 후
    * 새로운 노드를 tail로 설정해줌.


더블리 링크드 리스트 삽입 연산

 - 리스트가 비었을 때
    * head와 tail을 새로운 노드로 설정해줌.

 - 이전 노드가 tail 일 때
    * 새로운 노드의 prev가 이전 노드를 가리키게 하고
    * 이전 노드의 next가 새로운 노드를 가리키게 한 뒤
    * 새로운 노드를 tail로 설정한다.

 - 리스트가 비어있지 않고 이전 노드가 tail이 아닐 때
    * 새로운 노드의 next를 이전 노드에 prev를 이전노드의 next를 가리키게 하고
    * 이전 노드의 다음 노드의 prev를 새로운 노드를 가리키게 하고
    * 이전 노드의 next가 새로운 노드를 가리키게 한다.


더블리 링크드 리스트 맨 앞 삽입 연산

 - 리스트가 비었을 때
    * head와 tail을 새로운 노드로 설정해줌.

 - 리스트가 비어있지 않을 때
    * 새로운 노드의 next가 head 노드를 가리키게 하고
    * head 노드의 prev가 새로운 노드를 가리키게 한 뒤
    * 새로운 노드를 head 노드로 설정한다.


더블리 링크드 리스트 삭제 연산

메소드의 파라미터로 삭제하려는 노드를 넘겨준다.

 - 지우려는 노드가 마지막 남은 노드일 경우
    * head와 tail을 모두 None으로 바꾸어준다.

 - 지우려는 노드가 head일 경우
    * head를 다음 노드로 바꾸어준 후 다음 노드의 prev를 None으로 설정해준다.

 - 지우려는 노드가 tail일 경우
    * tail을 이전 노드로 바꾸어준 후 이전 노드의 next를 None으로 설정해준다.

 - 위 경우 모두 아닐 경우
    * 삭제할 노드의 prev의 next를 삭제할 노드의 next로 설정해주고
    * 삭제할 노드의 next의 prev를 삭제할 노드의 prev로 설정해준다.

ㄴ
더블리 링크드 리스트 시간 복잡도 정리

싱글리 리스트와 거의 비슷하지만
가장 뒤에 요소에 접근하고 삭제하는 연산에서
싱글리 링크드 리스트는 O(n+1)
더블리 링크드 리스트는 O(1+1) 이라는 차이가 있다.

- 맨 마지막 노드에 많이 접근해야한다면 싱글리 링크드 리스트보다 더블리 링크드 리스트가 더 효율적이다!